<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bridge Simulator</title>
  <style>
    body { font-family: sans-serif; margin: 16px; background: #f5f7fb; color: #0f172a; }
    #app { display: grid; grid-template-columns: 380px 1fr; gap: 16px; align-items: start; }
    .card { background: #fff; padding: 12px 14px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.08); }
    label { display: block; margin: 8px 0 4px; font-weight: 600; }
    input, select, button { width: 100%; padding: 8px; margin-bottom: 8px; border-radius: 6px; border: 1px solid #d4d8e1; }
    button { cursor: pointer; border: none; background: #2563eb; color: #fff; font-weight: 600; }
    button.secondary { background: #f1f5f9; color: #0f172a; border: 1px solid #d4d8e1; }
    #status { padding: 10px; border-radius: 8px; font-weight: 700; margin: 10px 0; }
    .ok { background: #e6f7ed; color: #1f7a3d; }
    .fail { background: #ffecec; color: #c02828; }
    canvas { width: 100%; height: 480px; background: #eef2f7; border-radius: 10px; cursor: grab; }
    canvas.dragging { cursor: grabbing; }
    ul { padding-left: 18px; }
    li { margin: 4px 0; font-size: 14px; }
    small { color: #475569; }
    .inline { display: flex; gap: 8px; }
    .inline > div { flex: 1; }
  </style>
</head>
<body>
<h2>Bridge Simulator (forces, bending, stress, deflection)</h2>
<div id="app">
  <div class="card">
    <label>Bridge type</label>
    <select id="structureType">
      <option value="beam">Beam (simple span)</option>
      <option value="truss">Truss (triangulated)</option>
      <option value="arch">Arch (thrust-based)</option>
    </select>

    <label>Material preset</label>
    <select id="bridgeMaterial">
      <option value="steel">Steel I-beam</option>
      <option value="concrete">Prestressed concrete</option>
      <option value="wood">Glulam timber</option>
      <option value="custom">Custom</option>
    </select>

    <div class="inline">
      <div>
        <label>Span (m)</label>
        <input type="number" id="span" value="20" min="5" max="150" step="1">
      </div>
      <div>
        <label>Capacity (kN)</label>
        <input type="number" id="capacity" value="1200" min="100" max="5000" step="50">
      </div>
    </div>

    <div class="inline">
      <div>
        <label>Moment capacity (kN·m)</label>
        <input type="number" id="momentCapacity" value="2500" min="100" max="10000" step="50">
      </div>
      <div>
        <label>Damping (visual only)</label>
        <input type="number" id="damping" value="0.5" min="0" max="1" step="0.1">
      </div>
    </div>

    <div class="inline">
      <div>
        <label>Flexural rigidity EI (kN·m²)</label>
        <input type="number" id="ei" value="20000" min="500" max="200000" step="500">
      </div>
      <div>
        <label>Section modulus Z (m³)</label>
        <input type="number" id="sectionModulus" value="2" min="0.1" max="10" step="0.1">
      </div>
    </div>

    <label>Add load</label>
    <select id="loadType">
      <option value="car">Car (15 kN)</option>
      <option value="truck">Truck (80 kN)</option>
      <option value="bus">Bus (60 kN)</option>
      <option value="custom">Custom</option>
    </select>
    <div class="inline">
      <div>
        <label>Custom weight (kN)</label>
        <input type="number" id="customWeight" value="50" min="1" max="500" step="5" disabled>
      </div>
      <div>
        <label>Position (0–100%)</label>
        <input type="number" id="position" value="50" min="0" max="100" step="5">
      </div>
    </div>
    <button id="addBtn">Add load</button>
    <button class="secondary" id="resetBtn">Reset loads</button>

    <div id="status" class="ok">Bridge OK</div>
    <p><strong>Total load:</strong> <span id="totalLoad">0</span> kN</p>
    <p><strong>Capacity:</strong> <span id="capText">1200</span> kN</p>
    <p><strong>Max bending moment:</strong> <span id="momentText">0</span> / <span id="momentCapText">2500</span> kN·m</p>
    <p><strong>Max stress (M/Z):</strong> <span id="stressText">0</span> kN/m²</p>
    <p><strong>Support reactions:</strong> L <span id="leftReaction">0</span> kN, R <span id="rightReaction">0</span> kN</p>
    <p><strong>Max deflection:</strong> <span id="deflectionText">0</span> m (limit L/360)</p>

    <h4>Loads (drag on canvas to move):</h4>
    <ul id="loadList"></ul>
  </div>

  <div class="card">
    <canvas id="canvas" width="1100" height="480"></canvas>
    <small>Blue bars = loads (drag to move). Green = deflection. Red = shear diagram. Purple = bending moment diagram.</small>
  </div>
</div>

<script>
(function() {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const structureType = document.getElementById('structureType');
  const bridgeMaterial = document.getElementById('bridgeMaterial');
  const spanInput = document.getElementById('span');
  const capacityInput = document.getElementById('capacity');
  const momentCapacityInput = document.getElementById('momentCapacity');
  const eiInput = document.getElementById('ei');
  const sectionModulusInput = document.getElementById('sectionModulus');
  const dampingInput = document.getElementById('damping');
  const loadType = document.getElementById('loadType');
  const customWeight = document.getElementById('customWeight');
  const positionInput = document.getElementById('position');
  const addBtn = document.getElementById('addBtn');
  const resetBtn = document.getElementById('resetBtn');
  const loadList = document.getElementById('loadList');
  const totalLoadEl = document.getElementById('totalLoad');
  const capText = document.getElementById('capText');
  const momentText = document.getElementById('momentText');
  const momentCapText = document.getElementById('momentCapText');
  const stressText = document.getElementById('stressText');
  const leftReactionEl = document.getElementById('leftReaction');
  const rightReactionEl = document.getElementById('rightReaction');
  const deflectionText = document.getElementById('deflectionText');
  const status = document.getElementById('status');

  // Presets for material properties and capacities
  const materials = {
    steel: { capacity: 1200, moment: 2500, ei: 20000, z: 2.0 },
    concrete: { capacity: 900, moment: 1800, ei: 15000, z: 1.5 },
    wood: { capacity: 500, moment: 800, ei: 7000, z: 0.9 },
    custom: null
  };

  // Simplified structure-type behavior multipliers
  const structures = {
    beam:  { stiffnessFactor: 1.0, momentFactor: 1.0 },
    truss: { stiffnessFactor: 1.5, momentFactor: 0.8 },
    arch:  { stiffnessFactor: 2.0, momentFactor: 0.6 }
  };

  let loads = [];
  let dragId = null;

  function typeToWeight(t) {
    if (t === 'car') return 15;
    if (t === 'truck') return 80;
    if (t === 'bus') return 60;
    return Number(customWeight.value) || 0;
  }

  function applyPreset() {
    const preset = materials[bridgeMaterial.value];
    if (!preset) return;
    capacityInput.value = preset.capacity;
    momentCapacityInput.value = preset.moment;
    eiInput.value = preset.ei;
    sectionModulusInput.value = preset.z;
    render();
  }

  bridgeMaterial.addEventListener('change', applyPreset);
  structureType.addEventListener('change', render);

  loadType.addEventListener('change', () => {
    customWeight.disabled = loadType.value !== 'custom';
  });

  addBtn.addEventListener('click', () => {
    const w = typeToWeight(loadType.value);
    const posPct = Math.max(0, Math.min(100, Number(positionInput.value)));
    const span = Math.max(1, Number(spanInput.value));
    loads.push({ w, pos: posPct / 100 * span });
    render();
  });

  resetBtn.addEventListener('click', () => {
    loads = [];
    render();
  });

  [spanInput, capacityInput, momentCapacityInput, dampingInput, eiInput, sectionModulusInput].forEach(el => {
    el.addEventListener('input', render);
  });

  function computeReactions(span) {
    const total = loads.reduce((s, l) => s + l.w, 0);
    const momentSum = loads.reduce((s, l) => s + l.w * l.pos, 0);
    const right = span > 0 ? momentSum / span : 0;
    const left = total - right;
    return { left, right, total };
  }

  function computeDiagrams(span, reactions, typeConfig) {
    const steps = 200;
    const shearPoints = [];
    const momentPoints = [];
    let maxShear = 0;
    let maxMoment = 0;
    for (let i = 0; i <= steps; i++) {
      const x = (i / steps) * span;
      let shear = reactions.left;
      loads.forEach(l => { if (x >= l.pos) shear -= l.w; });
      let moment = reactions.left * x - loads.reduce((s, l) => s + (x >= l.pos ? l.w * (x - l.pos) : 0), 0);
      moment *= typeConfig.momentFactor; // structure effect on bending
      maxShear = Math.max(maxShear, Math.abs(shear));
      maxMoment = Math.max(maxMoment, Math.abs(moment));
      shearPoints.push({ x, v: shear });
      momentPoints.push({ x, v: moment });
    }
    return { shearPoints, momentPoints, maxShear, maxMoment };
  }

  // Simple numerical double-integration for deflection
  function computeDeflection(diagrams, span, ei, typeConfig) {
    const pts = diagrams.momentPoints;
    if (!pts.length) return { deflections: [], max: 0 };
    const deflections = [];
    let slope = 0;
    let defl = 0;
    const stiffEI = Math.max(1, ei) * typeConfig.stiffnessFactor;
    for (let i = 0; i < pts.length; i++) {
      if (i > 0) {
        const dx = (pts[i].x - pts[i - 1].x);
        const mAvg = (pts[i].v + pts[i - 1].v) / 2;
        slope += (mAvg / stiffEI) * dx;
        defl += slope * dx;
      }
      deflections.push(defl);
    }
    // Anchor deflection to zero at supports
    const end0 = deflections[0];
    const end1 = deflections[deflections.length - 1];
    const corrected = deflections.map((d, i) => {
      const t = i / (deflections.length - 1);
      const baseline = end0 + t * (end1 - end0);
      return d - baseline;
    });
    const maxDefl = corrected.reduce((m, v) => Math.max(m, Math.abs(v)), 0);
    return { deflections: corrected, max: maxDefl };
  }

  function drawBridge(span, reactions, diagrams, deflection) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const margin = 50;
    const yBeam = canvas.height * 0.6;
    const scaleX = (canvas.width - 2 * margin) / span;

    // Beam baseline
    ctx.strokeStyle = '#111827';
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.moveTo(margin, yBeam);
    ctx.lineTo(canvas.width - margin, yBeam);
    ctx.stroke();

    // Supports
    ctx.fillStyle = '#6b7280';
    ctx.fillRect(margin - 22, yBeam, 44, 50);
    ctx.fillRect(canvas.width - margin - 22, yBeam, 44, 50);

    // Tick marks
    ctx.strokeStyle = '#cbd5e1';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 10; i++) {
      const x = margin + i * (canvas.width - 2 * margin) / 10;
      ctx.beginPath();
      ctx.moveTo(x, yBeam);
      ctx.lineTo(x, yBeam - 10);
      ctx.stroke();
    }

    drawDeflection(deflection, span, scaleX, margin, yBeam);
    drawLoads(span, scaleX, margin, yBeam);
    drawReactions(reactions, margin, yBeam);
    drawDiagrams(diagrams, span, scaleX, margin);
  }

  function drawDeflection(deflection, span, scaleX, margin, yBeam) {
    if (!deflection.deflections.length) return;
    const maxVis = Math.max(0.001, deflection.max);
    const scaleY = Math.min(140, 140 / maxVis); // scale visually
    ctx.strokeStyle = '#16a34a';
    ctx.lineWidth = 2;
    ctx.beginPath();
    deflection.deflections.forEach((d, i) => {
      const x = margin + (span * i / (deflection.deflections.length - 1)) * scaleX;
      const y = yBeam + d * scaleY;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.stroke();
    ctx.fillStyle = '#16a34a';
    ctx.font = '12px sans-serif';
    ctx.fillText('Deflection (scaled)', margin + 6, yBeam + 30);
  }

  function drawLoads(span, scaleX, margin, yBeam) {
    loads.forEach((load, idx) => {
      const x = margin + load.pos * scaleX;
      const h = Math.min(160, load.w * 1.2);
      ctx.fillStyle = '#1d4ed8';
      ctx.fillRect(x - 14, yBeam - h, 28, h);

      ctx.fillStyle = '#0f172a';
      ctx.font = '12px sans-serif';
      ctx.fillText(`${load.w} kN`, x - 18, yBeam - h - 6);
      ctx.fillText(`#${idx + 1}`, x - 10, yBeam + 16);
    });
  }

  function drawReactions(reactions, margin, yBeam) {
    const arrow = (x, y, dir) => {
      ctx.strokeStyle = '#16a34a';
      ctx.fillStyle = '#16a34a';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x, y - dir * 50);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x - 6, y - dir * 50 + dir * 12);
      ctx.lineTo(x + 6, y - dir * 50 + dir * 12);
      ctx.lineTo(x, y - dir * 50);
      ctx.fill();
    };
    arrow(margin, yBeam + 4, 1);
    arrow(canvas.width - margin, yBeam + 4, 1);

    ctx.fillStyle = '#16a34a';
    ctx.font = '12px sans-serif';
    ctx.fillText(`${reactions.left.toFixed(1)} kN`, margin - 28, yBeam + 70);
    ctx.fillText(`${reactions.right.toFixed(1)} kN`, canvas.width - margin - 34, yBeam + 70);
  }

  function drawDiagrams(diagrams, span, scaleX, margin) {
    const shearBase = canvas.height * 0.22;
    const momentBase = canvas.height * 0.40;
    const shearScale = diagrams.maxShear > 0 ? (canvas.height * 0.14) / diagrams.maxShear : 0;
    const momentScale = diagrams.maxMoment > 0 ? (canvas.height * 0.16) / diagrams.maxMoment : 0;

    ctx.lineWidth = 2;

    // Shear diagram
    ctx.strokeStyle = '#ef4444';
    ctx.beginPath();
    diagrams.shearPoints.forEach((p, i) => {
      const x = margin + p.x * scaleX;
      const y = shearBase - p.v * shearScale;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.stroke();
    ctx.fillStyle = '#ef4444';
    ctx.font = '12px sans-serif';
    ctx.fillText('Shear (kN)', margin + 6, shearBase - 6);

    // Moment diagram
    ctx.strokeStyle = '#8b5cf6';
    ctx.beginPath();
    diagrams.momentPoints.forEach((p, i) => {
      const x = margin + p.x * scaleX;
      const y = momentBase - p.v * momentScale;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.stroke();
    ctx.fillStyle = '#8b5cf6';
    ctx.font = '12px sans-serif';
    ctx.fillText('Moment (kN·m)', margin + 6, momentBase - 6);

    // Axes
    ctx.strokeStyle = '#cbd5e1';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin, shearBase); ctx.lineTo(canvas.width - margin, shearBase);
    ctx.moveTo(margin, momentBase); ctx.lineTo(canvas.width - margin, momentBase);
    ctx.stroke();
  }

  function updateStatus(total, capacity, maxMoment, momentCapacity, maxDeflection, span, stress, allowableDeflection) {
    totalLoadEl.textContent = total.toFixed(1);
    capText.textContent = capacity.toFixed(1);
    momentText.textContent = maxMoment.toFixed(1);
    momentCapText.textContent = momentCapacity.toFixed(1);
    stressText.textContent = stress.toFixed(2);
    deflectionText.textContent = `${maxDeflection.toFixed(4)} m (limit ${allowableDeflection.toFixed(4)} m)`;
    const overload = total > capacity;
    const bendFail = maxMoment > momentCapacity;
    const deflFail = maxDeflection > allowableDeflection;
    if (!overload && !bendFail && !deflFail) {
      status.textContent = 'Bridge OK';
      status.className = 'ok';
    } else {
      const reasons = [];
      if (overload) reasons.push('total load exceeds capacity');
      if (bendFail) reasons.push('bending moment exceeds capacity');
      if (deflFail) reasons.push('deflection exceeds limit');
      status.textContent = 'Bridge FAILED: ' + reasons.join(' & ');
      status.className = 'fail';
    }
  }

  function renderList(span) {
    loadList.innerHTML = '';
    loads.forEach((l, i) => {
      const item = document.createElement('li');
      item.textContent = `#${i + 1}: ${l.w} kN at ${l.pos.toFixed(2)} m (${(l.pos / span * 100).toFixed(1)}%)`;
      loadList.appendChild(item);
    });
  }

  function render() {
    const span = Math.max(1, Number(spanInput.value));
    const capacity = Math.max(1, Number(capacityInput.value));
    const momentCapacity = Math.max(1, Number(momentCapacityInput.value));
    const ei = Math.max(1, Number(eiInput.value));
    const z = Math.max(0.01, Number(sectionModulusInput.value));
    const typeConfig = structures[structureType.value] || structures.beam;
    const reactions = computeReactions(span);
    const diagrams = computeDiagrams(span, reactions, typeConfig);
    const deflection = computeDeflection(diagrams, span, ei, typeConfig);
    const stress = diagrams.maxMoment / z;
    const allowableDeflection = span / 360; // common serviceability guideline

    drawBridge(span, reactions, diagrams, deflection);
    renderList(span);
    leftReactionEl.textContent = reactions.left.toFixed(1);
    rightReactionEl.textContent = reactions.right.toFixed(1);
    updateStatus(reactions.total, capacity, diagrams.maxMoment, momentCapacity, deflection.max, span, stress, allowableDeflection);
  }

  function canvasToSpan(xCanvas, span) {
    const margin = 50;
    const scaleX = (canvas.width - 2 * margin) / span;
    const xClamped = Math.min(canvas.width - margin, Math.max(margin, xCanvas));
    return (xClamped - margin) / scaleX;
  }

  function pickLoad(xCanvas, span) {
    const margin = 50;
    const scaleX = (canvas.width - 2 * margin) / span;
    const threshold = 18; // pick radius
    for (let i = loads.length - 1; i >= 0; i--) {
      const loadX = margin + loads[i].pos * scaleX;
      if (Math.abs(loadX - xCanvas) < threshold) return i;
    }
    return null;
  }

  // Drag to move loads
  canvas.addEventListener('pointerdown', (e) => {
    const span = Math.max(1, Number(spanInput.value));
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const id = pickLoad(x, span);
    if (id !== null) {
      dragId = id;
      canvas.classList.add('dragging');
    }
  });

  canvas.addEventListener('pointermove', (e) => {
    if (dragId === null) return;
    const span = Math.max(1, Number(spanInput.value));
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    loads[dragId].pos = Math.max(0, Math.min(span, canvasToSpan(x, span)));
    render();
  });

  canvas.addEventListener('pointerup', () => {
    dragId = null;
    canvas.classList.remove('dragging');
  });
  canvas.addEventListener('pointerleave', () => {
    dragId = null;
    canvas.classList.remove('dragging');
  });

  applyPreset();
  render();
})();
</script>
</body>
</html>
